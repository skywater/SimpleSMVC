<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
    xsi:schemaLocation="
    	http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-4.3.xsd
    ">
    <!-- 启用最新的注解解析器、映射器； Spring默认情况下使用的是一些旧版本注解解析器、映射器、转换器等 -->
    <!-- 开启注解模式驱动·需要上面的xmlns:context和xsi:schemaLocation对应的位置 -->  
    <!-- spring3.1开始，应该用RequestMappingHandlerMapping来替换 DefaultAnnotationHandlerMapping，
    	   用 RequestMappingHandlerAdapter来替换 AnnotationMethodHandlerAdapter -->
    <!-- 标签对应的实现类是org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser，
    	   这个类主要注册8个类的实例：
         1.RequestMappingHandlerMapping处理@RequestMapping注解;
    	 2.BeanNameUrlHandlerMapping将controller类的名字映射为请求url;
    	 1和2都实现了HandlerMapping接口，用来处理请求映射;
    	 3.RequestMappingHandlerAdapter处理@Controller注解的控制器类;
    	 4.处理继承HttpRequestHandlerAdapter类的控制器类;
    	 5.处理继承SimpleControllerHandlerAdapter类的控制器。所以这三个是用来处理请求的。
    	   具体点说就是确定调用哪个controller的哪个方法来处理当前请求。
    	 6·ExceptionHandlerExceptionResolver、
    	 7·ResponseStatusExceptionResolver、
    	 8·DefaultHandlerExceptionResolver
    	   全部继承AbstractHandlerExceptionResolver类,
    	   这个类实现HandlerExceptionResolver,该接口定义：接口实现的对象可以解决处理器映射、执行期间抛出的异常，还有错误的视图。
    	   总结：该类主要是用来帮助我们处理请求映射，决定是哪个controller的哪个方法来处理当前请求，异常处理。 -->
    <mvc:annotation-driven/>
    
    <!-- 扫描包中所有注解的类,并自动注入为Bean类放到Bean工厂,因此就可以将 <context:annotation-config/>移除 -->
    <!-- 它的实现类是org.springframework.context.annotation.ComponentScanBeanDefinitionParser，
            注解包括:@Component、@Repository·数据持久层Dao、@Service·业务层、@Controller·控制层、@Required、
    @Resource、@Autowired、 @PostConstruct、@PreDestroy、@PersistenceContext、@PersistenceUnit -->
    <!-- @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。
    	 这四种注解(@Repository、@Service、@Controller、@Component)仅仅是角色不同，但实质都一样 -->
    <context:component-scan base-package="com.company.springmvc.services" />
	<!-- 可以：com/com.**/com.*/com.web/com.web.**/com.web.* -->
	
	
	<!-- 静态资源被DispatcherServlet过滤，无法访问，必须配置静态资源过滤，可以直接访问，而不经过controller
	               ，或者在web.xml里直接过滤<url-pattern>*.js</url-pattern> -->
	<!-- 对静态资源文件的访问，必须要配置mvc:annotation-driven -->
	<!-- mapping映射到 ResourceHttpRequestHandler进行处理，location指定静态资源的位置,注意必须是webapp根目录下的路径。 -->
	<!-- 经测试map，只有如下写法可以找到，无论是mapping还是location，其余写法
	/Resources/*/**、/Resources/**、/**/Resources/css/*、/**/Resources/css/**均不能找到 -->
 	<!-- 如果多个位置可以指定为逗号分隔列表，并且将按照指定的顺序检查给定资源的位置，但最好分离
 	<mvc:resources mapping="/Resources/**" location="/Resources/css/,/Resources/js/,/Resources/img/" />
     -->
    <mvc:resources mapping="/Resources/css/**" location="/Resources/css/" />
  	<mvc:resources mapping="/Resources/img/**" location="/Resources/img/" />
  	<mvc:resources mapping="/Resources/js/**" location="/Resources/js/" />

	<!-- DispatcherServlet拦截器，对转向页面的路径解析·视图渲染 jsp/freemaker/velocity-->
	<!-- ViewResolver接口的Bean，它的任务就是返回一个视图的具体实现(HTML、JSP、PDF等等). -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <!-- Jstl包·使用JSP页面进行输出 -->
	 	<!-- <property name ="viewClass" value= "org.springframework.web.servlet.view.JstlView" /> -->
		
        <!-- 制定页面存放的路径 -->
        <property name="prefix" value="/WEB-INF/pages/"/>
        <!-- 文件的后缀 -->
        <property name="suffix" value=".jsp"/>
    </bean>

</beans>
